;; Self test script
;; (loadFile "src/lisp/eval/Verify.jisp")

(resetTestStatistics)

(verify 1 1)
(verify 2 2)
(verify (+ 2 3) 5)
(setq a 5)
(verify a 5)
(verify (+ a 3) 8)

(define alpha (x)
   (+ a x 4))

(verify a 5)
(verify (alpha 3) 12)

(setq a 6) 
(verify (alpha 3) 13) 

(define foo (x)
	(setq a x))
(foo 3)
(verify a 3)
(foo 5)
(verify a 5) 

(verify (if true 1 2) 1)
(verify (if false 1 2) 2)

(define foo (x) (repeat x (setq a (+ a 1))))
(setq a 0)
(foo 5)
(verify a 5)

(define foo () (quote bar))
(eq (foo) 'bar)

(verify (> (static "java.lang.System" "currentTimeMillis") 1526859416568) true)

(define foo ()
	(static "java.lang.System" "currentTimeMillis"))

(verify (> (foo) 152685941) true)

(define foo (x) (let ((a 1) (b 2)) (+ a b x)))
(verify (foo 3) 6)

(define foo () (let ((a 1) (b 2)) a))
(verify (foo) 1)

(setq a 11)
(setq b 22)
(define foo (x) (let ((a b) (b a)) (if x a b)))
(verify (foo true) 22)
(verify (foo false) 11)

(define foo () (let* ((a b) (b a)) b))
(define bar () (let ((a b) (b a)) b))
(verify (foo) 22)
(verify (bar) 11)

(define foo (x) (cond ((= x 1) 'alpha) ((= x 2) 'beta) ((= x 3) 'gamma) (true 'delta)))
(verify (foo 1) 'alpha)
(verify (foo 2) 'beta)
(verify (foo 3) 'gamma)
(verify (foo 4) 'delta)
(verify (foo 5) 'delta)

(define foo (x) (cond ((= x 1) 'alpha) ((= x 2) 'beta) ((= x 3) 'gamma)))
(verify (foo 1) 'alpha)
(verify (foo 2) 'beta)
(verify (foo 3) 'gamma)
(verify (foo 4) null)
(verify (foo 5) null)

; This will test compilation of a call to an undefined function.
(define factorial (n)
	(if (<= n 0)
		1
		(* n (factorial (- n 1)))))

(verify (factorial 5) 120)
	
(define foo (x) (length x))
(verify (foo "foobar") 6)

(verify (* 3 4) 12)
(verify (* 3.0 4) 12.0)
(verify (* 3 4.0) 12.0)
(verify (* 3.0 4.0) 12.0)

(verify (not true) false)
(verify (not false) true)
(verify (not 1) false)
(verify (null null) true)
(verify (null 'foo) false)
(verify (null 0) false)
(verify (null (list)) false)

(verify (sign 1) 1)
(verify (sign -1) -1)
(verify (sign 0) 0)
(verify (sign 2) 1)
(verify (sign -2) -1)

(verify (sign 1.0) 1)
(verify (sign -1.0) -1)
(verify (sign 0.0) 0)
(verify (sign 2.5) 1)
(verify (sign -2.5) -1)

(verify (+ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20) 210)

(define foo ()
	(+ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20))
(verify (foo) 210)

(def isprime (a)
  (let ((b 2)
  		(result true))
    (while (and (<= (* b b) a) result)
      (if (zerop (rem a b))
      	  (setq result false)
      	  (setq b (1+ b))))
    result))

(def collectPrimes (n)
    (let ((i 2) (result (list)))
      (while (<= (size result) n)
        (when (isprime i) (add result i))
        (setq i (1+ i)))
      result))

(verify (collectPrimes 10) '(2 3 5 7 11 13 17 19 23 29 31))

(printf "Testing compiled prime number test %n")

; Now do it compiled
(define isprime (a)
  (let ((b 2)
  		(result true))
    (while (and (<= (* b b) a) result)
      (if (zerop (rem a b))
      	  (setq result false)
      	  (setq b (1+ b))))
    result))

(define collectPrimes (n)
    (let ((i 2) (result (list)))
      (while (<= (size result) n)
        (when (isprime i) (add result i))
        (setq i (1+ i)))
      result))

(verify (collectPrimes 10) '(2 3 5 7 11 13 17 19 23 29 31))
        
(define foo (x) (when x 1 2))
(verify (foo 1) 2)
(verify (foo 'bar) 2)
(verify (foo null) 2)
(verify (foo true) 2)
(verify (foo false) null)

(define foo (x) (unless x 1 2))
(verify (foo 1) null)
(verify (foo 'bar) null)
(verify (foo null) null)
(verify (foo true) null)
(verify (foo false) 2)

(define foo () (if 'foo 1  2))
(verify (foo) 1)

(sleep 0.2)
(printTestStatistics)

; And quit
(exit)


(define isprime (a) ;ok
  (let ((b 2)
  		(result true))
    (while (and (<= (* b b) a) result)
      (when (zerop (rem a b)) 
      	(setq result false))
      (setq b (1+ b))
      )
    result))
    
(define isprime (a) ; ok
  (let ((b 2)
  		(result true))
    (while (and (<= (* b b) a) result)
      (if (zerop (rem a b)) 
      	  (setq result false))
      (setq b (1+ b))
      )
    result))
 
(define isprime (a) ; bad
  (let ((b 2)
  		(result true))
    (while (and (<= (* b b) a) result)
      (if (zerop (rem a b)) 
      	  (setq result false)
          (setq b (1+ b)))
      )
    result))